Projekt kilkumodułowy:
1) Po stworzeniu projektu definiujemy moduł parenta w pliku pom.xml, poprzez wpisanie typu pakietu
    (<packaging>pom</packaging>)
    'pom' to "pojemnik" submodułów
2) kasujemy defaultowy folder src
3) P-klik na nazwie projektu -> New -> Module
4) Dodajemy Logbacka w example/src/resources, czyli plik logback.xml
    (jeśli przy tworzeniu obiektu loggera IDEA nie proponuje importu klasy Logger z pakietu org.slf4j.Logger, to Maven -> reload all)
        private static final Logger log = LoggerFactory.getLogger([xxx].class);
5) W pliku pom.xml (głównym, nie w nowym module!) definiujemy dependencies
    Robimy to w tagu <dependencyManagement> - wtedy submoduły je dziedziczą
6) Kolejna dependency: Spring Context (mvnrepository.com)
7) Przenosimy się do pliku pom.xml w module 'example' i dodajemy dependencies, te same co w pomie głównym
    wpisujemy artifactId (nazwa musi być ta sama, co w głównym pomie) i groupId
    wersja się sama zaciągnie z poma głównego
    (jeśli nie działa, to Maven -> root -> Execute Maven goal -> mvn clean install)
    Jeśli zrobimy to dobrze, to po lewej stronie, przy numerze wiersza, pojawi się ikonka,
        której kliknięcie przeniesie nas do odpowiedniej dependency w pomie głównym
8) Dodajemy Spring Container, aby stworzył nam beana,
    i go konfigurujemy - tutaj nie za pomocą adnotacji, ale pliku XML:
    w pakiecie resources tworzymy plik beans.xml
    (podkładka: https://docs.spring.io/spring-framework/docs/current/reference/html/example.html#beans)
    dodajemy tam beana (podając klasę oraz ID)
9) tworzymy instancję Containera:
    w klasie Main (lub innej) dodajemy pole (CONFIG_LOCATION) z lokalizacją beana
    tworzymy kontekst, a następnie wyciągamy z niego beana
    następnie wywołujemy na powyższym odpowiednią metodę
    po wszystkim zamykamy kontener (kontekst)
10) implementujemy logikę gry (interfejs Game i klasa GameImpl)
    dodajemy odpowiedni kod w klasie Main
11) poprawiamy błąd w klasie GameImpl (brak inicjalizacji pola numberGenerator)
    dodajemy w tej klasie konstruktor oraz zmieniamy implementację beana
    -> dodajemy <constructor-arg ref="">, aby wskazać ID, które będzie wstrzyknięte przez kontener
    ref z beana game musi być taki sam jak bean numberGenerator
12) istnieje inny sposób na inicjalizację pola numberGenerator: setter-based dependency injection
    -> kasujemy konstruktor z klasy GameImpl
    -> tworzymy settera dla pola numberGenerator
    -> w bean.xml zmieniamy beana 'game':
        => usuwamy constructor-arg
        => dodajemy property (name musi być takie samo jak nazwa pola w klase GameImpl,
            a ref - takie samo jak nazwa odpowiedniego beana w beans.xml)
13) jeśli stoimy przed wyborem, czy używać setter dependency injection, czy raczej
    constructor dependency injection (DI), Buchalka zaleca constructor DI dla
    dependencies obligatoryjnych, a setter DI dla opcjonalnych
    zespół Springa zaleca stosowanie constructor dependency injection
14) Bean Lifecycle Callbacks
    zazwyczaj do zarządzania cyklem życia beanów używamy metod nazywanych
    init()/initialize() - dla inicjalizacji
    destroy()/dispose() - dla niszczenia/zamykania
    Można też skonfigurować Spring Containera do odszukania odpowiednich metod
        (adnotacje @PostConstruct i @PreDestroy)
    -> z klasy Main usuwamy game.reset()
    -> w beans.xml dodajemy nowego beana:
        <bean class="org.springframework.context.annotation.CommonAnnotationBeanPostProcessor"/>
    -> w głównym pomie dodajemy dependency (Annotation API), a w pomie modułu: to samo, ale bez numeru wersji
    -> w klasie GameImpl nad metodą reset() dodajemy adnotację @PostConstruct
    -> jeśli @PostConstruct świeci się na czerwono: klik -> add Maven Dependency
        -> search for artifact -> wpisać 'javax.annotation' -> add
       alternatywnie: Maven -> mvn clean install
15) @Autowired
    -> w beans.xml dodajemy <context:annotation-config>
        (automatycznie doda się tam 'xmlns:context' oraz 2 adresy www w 'xsi:schemaLocation')
    -> usuwamy beana CommonAnnotationBeanPostProcessor (dodanego w pkt 14)
        od teraz używany będzie autowiring
    -> z beana 'game' usuwamy <property>
    -> z GameImpl usuwamy setter do pola numberGenerator
    -> nad polem numberGenerator podajemy @Autowired
    Dobrą praktyką jest używanie @Autowired dla konstruktora (constructor injection):
        pozwala to na wstrzykiwanie elementów aplikacji jako niezmiennych obiektów
        oraz pozwala upewnić się, że wymagane dependencies nie są nullami
16) Zmiana na projekt obsługiwany adnotacjami [Git branch: m05_components]
    -> beans.xml: zamiana <context:annotation-config> na <context:component-scan base-package="[pakiet]]"/>
    -> usuwamy wszystkie beany
    -> dodajemy @Component do implementacji interfejsów (ale nie do samych interfejsów,
        bo one nie powinny być powiązane ze swoimi implementacjami)
    -> w klasie Main usuwamy nazwy beanów w context.getBean() - Spring nadaje nazwy automatycznie
17) Annotation Configuration [Git branch: m06_annotation_configuration]
    -> usuwamy plik beans.xml
    -> w pakiecie tworzymy klasę AppConfig
    -> w klasie Main zmieniamy sposób tworzenia kontekstu (new AnnotationConfigApplicationContext)
18) Jeśli potrzebujemy jakiejś dodatkowej konfiguracji naszego beana (np. klasy GameImpl), to:
    -> usuwamy z klasy adnotację @Component
    -> dodajemy w klasie AppConfig odpowiedni kod:
        @Bean
        public Game game() {
        return new GameImpl();
        }
19) CHALLENGE 1:
    1) create an interface MessageGenerator with 2 methods
    2) create a class MessageGeneratorImpl and implement methods to return any String
        (e.g. "calling method xxx")
    3) in MessageGeneratorImpl:
        - add a logger
        - add a field of type Game and autowire it
        - add a field guessCount(int) and initialize it to 10 for now (it will be changed later)
        - add a @PostConstruct method and log value of game to confirm it was autowired (e.g. not null)
    4) create a bean method (in AppConfig) that will create a MessageGenerator
    5) in the main method get the MessageGenerator beam and call both methods
    6) check the console output and confirm that both methods are called
20) CHALLENGE 2:
    1) create an new Maven module in the project with the name 'console'
    2) add the core project as a dependency
    3) moce the Main class to the console subproject
    4) run the Mian class from the console subproject and check that i't working the same
    Tip: for the core project dependency artifactId check the pom.xml in the core project




