Projekt kilkumodułowy:
1) Po stworzeniu projektu definiujemy moduł parenta w pliku pom.xml, poprzez wpisanie typu pakietu
    (<packaging>pom</packaging>)
    'pom' to "pojemnik" submodułów
2) kasujemy defaultowy folder src
3) P-klik na nazwie projektu -> New -> Module
4) Dodajemy Logbacka w example/src/resources, czyli plik logback.xml
    (jeśli przy tworzeniu obiektu loggera IDEA nie proponuje importu klasy Logger z pakietu org.slf4j.Logger, to Maven -> reload all)
        private static final Logger log = LoggerFactory.getLogger([xxx].class);
5) W pliku pom.xml (głównym, nie w nowym module!) definiujemy dependencies
    Robimy to w tagu <dependencyManagement> - wtedy submoduły je dziedziczą
6) Kolejna dependency: Spring Context (mvnrepository.com)
7) Przenosimy się do pliku pom.xml w module 'example' i dodajemy dependencies, te same co w pomie głównym
    wpisujemy artifactId (nazwa musi być ta sama, co w głównym pomie) i groupId
    wersja się sama zaciągnie z poma głównego
    (jeśli nie działa, to Maven -> root -> Execute Maven goal -> mvn clean install)
    Jeśli zrobimy to dobrze, to po lewej stronie, przy numerze wiersza, pojawi się ikonka,
        której kliknięcie przeniesie nas do odpowiedniej dependency w pomie głównym
8) Dodajemy Spring Container, aby stworzył nam beana,
    i go konfigurujemy - tutaj nie za pomocą adnotacji, ale pliku XML:
    w pakiecie resources tworzymy plik beans.xml
    (podkładka: https://docs.spring.io/spring-framework/docs/current/reference/html/example.html#beans)
    dodajemy tam beana (podając klasę oraz ID)
9) tworzymy instancję Containera:
    w klasie Main (lub innej) dodajemy pole (CONFIG_LOCATION) z lokalizacją beana
    tworzymy kontekst, a następnie wyciągamy z niego beana
    następnie wywołujemy na powyższym odpowiednią metodę
    po wszystkim zamykamy kontener (kontekst)
10) implementujemy logikę gry (interfejs Game i klasa GameImpl)
    dodajemy odpowiedni kod w klasie Main
11) poprawiamy błąd w klasie GameImpl (brak inicjalizacji pola numberGenerator)
    dodajemy w tej klasie konstruktor oraz zmieniamy implementację beana
    -> dodajemy <constructor-arg ref="">, aby wskazać ID, które będzie wstrzyknięte przez kontener
    ref z beana game musi być taki sam jak bean numberGenerator
12) istnieje inny sposób na inicjalizację pola numberGenerator: setter-based dependency injection
    -> kasujemy konstruktor z klasy GameImpl
    -> tworzymy settera dla pola numberGenerator
    -> w bean.xml zmieniamy beana 'game':
        => usuwamy constructor-arg
        => dodajemy property (name musi być takie samo jak nazwa pola w klase GameImpl,
            a ref - takie samo jak nazwa odpowiedniego beana w beans.xml)
13) jeśli stoimy przed wyborem, czy używać setter dependency injection, czy raczej
    constructor dependency injection (DI), Buchalka zaleca constructor DI dla
    dependencies obligatoryjnych, a setter DI dla opcjonalnych
    zespół Springa zaleca stosowanie constructor dependency injection
14) Bean Lifecycle Callbacks
    zazwyczaj do zarządzania cyklem życia beanów używamy metod nazywanych
    init()/initialize() - dla inicjalizacji
    destroy()/dispose() - dla niszczenia/zamykania
    Można też skonfigurować Spring Containera do odszukania odpowiednich metod
        (adnotacje @PostConstruct i @PreDestroy)
    -> z klasy Main usuwamy game.reset()
    -> w beans.xml dodajemy nowego beana:
        <bean class="org.springframework.context.annotation.CommonAnnotationBeanPostProcessor"/>
    -> w głównym pomie dodajemy dependency (Annotation API), a w pomie modułu: to samo, ale bez numeru wersji
    -> w klasie GameImpl nad metodą reset() dodajemy adnotację @PostConstruct
    -> jeśli @PostConstruct świeci się na czerwono: klik -> add Maven Dependency
        -> search for artifact -> wpisać 'javax.annotation' -> add
       alternatywnie: Maven -> mvn clean install
15) @Autowired
    -> w beans.xml dodajemy <context:annotation-config>
        (automatycznie doda się tam 'xmlns:context' oraz 2 adresy www w 'xsi:schemaLocation')
    -> usuwamy beana CommonAnnotationBeanPostProcessor (dodanego w pkt 14)
        od teraz używany będzie autowiring
    -> z beana 'game' usuwamy <property>
    -> z GameImpl usuwamy setter do pola numberGenerator
    -> nad polem numberGenerator podajemy @Autowired
    Dobrą praktyką jest używanie @Autowired dla konstruktora (constructor injection):
        pozwala to na wstrzykiwanie elementów aplikacji jako niezmiennych obiektów
        oraz pozwala upewnić się, że wymagane dependencies nie są nullami
16) Zmiana na projekt obsługiwany adnotacjami [Git branch: m05_components]
    -> beans.xml: zamiana <context:annotation-config> na <context:component-scan base-package="[pakiet]]"/>
    -> usuwamy wszystkie beany
    -> dodajemy @Component do implementacji interfejsów (ale nie do samych interfejsów,
        bo one nie powinny być powiązane ze swoimi implementacjami)
    -> w klasie Main usuwamy nazwy beanów w context.getBean() - Spring nadaje nazwy automatycznie
17) Annotation Configuration [Git branch: m06_annotation_configuration]
    -> usuwamy plik beans.xml
    -> w pakiecie tworzymy klasę AppConfig
    -> w klasie Main zmieniamy sposób tworzenia kontekstu (new AnnotationConfigApplicationContext)
18) Jeśli potrzebujemy jakiejś dodatkowej konfiguracji naszego beana (np. klasy GameImpl), to:
    -> usuwamy z klasy adnotację @Component
    -> dodajemy w klasie AppConfig odpowiedni kod:
        @Bean
        public Game game() {
        return new GameImpl();
        }
19) CHALLENGE 1:
    1) create an interface MessageGenerator with 2 methods
    2) create a class MessageGeneratorImpl and implement methods to return any String
        (e.g. "calling method xxx")
    3) in MessageGeneratorImpl:
        - add a logger
        - add a field of type Game and autowire it
        - add a field guessCount(int) and initialize it to 10 for now (it will be changed later)
        - add a @PostConstruct method and log value of game to confirm it was autowired (e.g. not null)
    4) create a bean method (in AppConfig) that will create a MessageGenerator
    5) in the main method get the MessageGenerator beam and call both methods
    6) check the console output and confirm that both methods are called
20) CHALLENGE 2:
    1) create an new Maven module in the project with the name 'console'
    2) add the core project as a dependency
    3) move the Main class to the console subproject
    4) run the Main class from the console subproject and check that it's working the same
    Tip: for the core project dependency artifactId check the pom.xml in the core project
21) Custom annotation - gdy używamy bean methods, to ich nazwa powinna być taka sama jak nazwa pola z @Autowired,
    CHYBA ŻE użyjemy qualifiers
    qualifier - adnotacja zastosowana do beana (wtedy container wie, co powinno być powiązane,
        niezależnie od nazwy beana lub pola)
    1) tworzymy custom qualifiera (New -> Java Class -> [nazwa] + wybieramy typ Annotation)
    2) konfigurujemy:
        -> @Target({..., ...})  => tu zaznaczamy, do czego nasza adnotacja będzie miała zastosowanie
            (np. do pola, do metody itp.)
        -> @Retention(RetentionPolicy.RUNTIME)  => jak długo nasze adnotacje będą trwać
        -> @Qualifier
    3) aby użyć custom qualifiera, musimy zrobić odpowiednią adnotację @[nazwa] przy bean method
        w klasie GameConfig oraz pola w klasach, które używają tych metod
22) Wgrywanie danych konfiguracyjnych z pliku
    1) tworzymy plik w folderze 'resources' i wprowadzamy tam dane (w formule 'klucz - wartość')
    2) w klasie GameConfig dodajemy adnotację @PropertySource wraz z adresem powyższego pliku
        (za atrybutem 'classpath:' lub 'file:')
    3) dodajemy adnotację @Value przy odpowiednich polach, wraz z parametrem
        ${nazwa.klucza}
    4) można dodać też wartość domyślną (ona się pojawi, gdy kontekst nie odnajdzie pliku w resources
        @Value("${nazwa.klucza:wartość.domyślna}")
23) CHALLENGE 3
    1) create a custom qualifier @MinNumber
    2) use game.properties to specify the value for minNumber
    3) create a bean method to create bean minNumber (tip: GameConfig)
    4) inject/autowire minNumber to NumberGeneratorImpl
    5) add a getter minNumber to NumberGenerator
    6) fix NumberGeneratorImpl to generate values between min and max
        (currently it generates between 0 and max)
    7) fix GameImpl to use minNumber for smallest and guess instead of using 0 as a starting value
24) CHALLENGE 4
    1) use constructor injection/autowiring in classes GameImpl, MessageGeneratorImpl and ConsoleNumberGuess
    2) AppConfig will be an empty class (no methods) - we can remove it and use
        GameConfig in Main class when creating the container
    3) make sure the project is working the same as it was prior to making any changes
    4) be careful about annotations that you have to add to GameConfig after removing the AppConfig class
25) Lombok
    1) File -> Settings -> Plugins -> search 'lombok' -> Search in repositories
        -> Lombok Plugin -> Install -> Restart Intellij IDEA -> OK
    2) File -> Settings -> Build, Execution, Deployment -> Compiler -> Annotation Processors
        -> Enable annotation processing + Obtain processors from classpath -> OK
    3) dodanie Lombok dependency:
        MVN Repository -> Project Lombok -> skopiować dependency do pom.xml (głównego)
        -> dependency do pom.xml w module 'core' (bez numeru wersji)
        UWAGA! Jeśli ściągamy bibliotekę w formie pliku .jar (nie jako kopię dependency z MVN Repo),
            to tworzymy nowy katalog w projekcie (np. libs), wklejamy tam plik lombok-edge.jar
            a w pliku pom.xml (w module 'core') dodajemy:
            <scope>system</scope>
            <systemPath>${basedir}/../libs/lombok-edge.jar</systemPath>
    => restart Intellij IDEA
    4) sprawdzamy, czy działa poprawnie:
        a) do klasy Main dodajemy @Slf4j
        b) wyskakuje error ("A field with that name already exists") -> chodzi tu o pole Loggera
            -> kasujemy 'log' (teraz ta adnotacja będzie odpowiadała za stworzenie Loggera)
    5) Jeśli np. jedno pole w danej klasie nie potrzebuje gettera/settera,
        to możemy całą klasę oznaczyć @Getter/@Setter, a przy tym polu dać adnotację
        @Getter(AccessLevel.NONE)
26) CHALLENGE 5
    go through the ConsoleNumberGuess, NumberGeneratorImpl and MessageGeneratorImpl classes
      and see what code you can remove and replace via Lombok annotations
    tip: you only need @Slf4j and @Getter annotations

27) Konwersja projektu na wersję ze Spring Boot 2
    1) dodajemy Spring Boot jako parenta istniejącego projektu (w pliku pom.xml)
        -> w sekcji properties usuwamy wszystkie wpisy poza wersją Javy
        -> usuwamy też całą sekcję <dependencyManagement>
        -> dodajemy parenta:
            <parent>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-parent</artifactId>
                <version>2.5.4</version>
                <relativePath/>
            </parent>
    2) modyfikujemy plik pom.xml w module 'core'
        -> usuwamy istniejące dependencies i dodajemy
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter</artifactId>
            </dependency>
    3) zmieniamy nazwę pliku 'logback.xml' na 'logback-spring.xml'
        modyfikujemy plik - usuwamy sekcje <appender> i <root> (będziemy wykorzystywać
            domyślną konfigurację ze Spring Boota)
        dodajemy:
            <include resource="org/springframework/boot/logging/logback/base.xml"/>
    4) modyfikujemy plik pom.xml w module 'console'
        -> w dependencies dodajemy Spring Boot Maven plugin (ponieważ w tym module mamy klasę Main)
            ten plugin pakuje całą aplikację w plik JAR (razem z dependencies)
    5) w module 'console' dodajemy plik 'application.properties' w folderze 'resources'
    6) ostatni krok to zastosowanie (włączenie) Spring Boota w naszej klasie Main
        -> dodanie adnotacji @SpringBootApplication do klasy
        -> usunięcie tworzenia kontekstu, bo Spring Boot robi to automatycznie
        -> używamy metody .run() z klasy SpringApplication:
            SpringApplication.run(Main.class, args);
   7) Maven -> clean install -> Spring nie może znaleźć klasy Game, bo znajduje się w innym pakiecie/module
        -> rozwiązanie 1: zastosować adnotację @ComponentScan
        -> rozwiązanie 2: przeniesienie klasy o 1 poziom wyżej (z 'example.console' do 'example')
28) Thymeleaf
    1) dodajemy dependency w pliku pom.xml (w module 'web') + mvn clean install
    2) w folderze 'resources' tworzymy katalog 'templates'
    3) w nim tworzymy pierwszy widok: new -> HTML 5 -> 'home'
    4) w tym pliku modyfikujemy 2 wiersz na:
        <html lang="en" xmlns:th="http://www.thymeleaf.org">
        => zdefiniowaliśmy powyżej skrót 'th', do którego będziemy się odwoływać jako atrybut
        => przykładowe atrybuty (dla linka):
            <a th:href="play" th:text="Play the Game"/>
            th:href="play"  -> adres (localhost:8080/play)
            th:text="Play the Game"  -> to się wyświetli na stronie jako hiperłącze
    5) tworzymy klasę do przechowywania zmiennych ViewNames (w kat. utils)
    6) tworzymy klasę ViewConfig (kat. 'config') i rejestrujemy tam kontroler widoku
        => ta klasa implementuje WebMvcConfigurer
        => override metody: addViewControllers:
            registry.addViewController("/").setViewName(ViewNames.HOME);
29) Spring Boot Developer Tools
    1) w module 'web' modyfikujemy pom.xml - dodajemy dependency
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
        </dependency>
    2) restart aplikacji: Build -> Build Project (albo Ctrl + F9)
        -> nie potrzeba zatrzymywać aplikacji, ani Mvn clan install