Projekt kilkumodułowy:
1) Po stworzeniu projektu definiujemy moduł parenta w pliku pom.xml, poprzez wpisanie typu pakietu
    (<packaging>pom</packaging>)
    'pom' to "pojemnik" submodułów
2) kasujemy defaultowy folder src
3) P-klik na nazwie projektu -> New -> Module
4) Dodajemy Logbacka w example/src/resources, czyli plik logback.xml
    (jeśli przy tworzeniu obiektu loggera IDEA nie proponuje importu klasy Logger z pakietu org.slf4j.Logger, to Maven -> reload all)
        private static final Logger log = LoggerFactory.getLogger([xxx].class);
5) W pliku pom.xml (głównym, nie w nowym module!) definiujemy dependencies
    Robimy to w tagu <dependencyManagement> - wtedy submoduły je dziedziczą
6) Kolejna dependency: Spring Context (mvnrepository.com)
7) Przenosimy się do pliku pom.xml w module 'example' i dodajemy dependencies, te same co w pomie głównym
    wpisujemy artifactId (nazwa musi być ta sama, co w głównym pomie) i groupId
    wersja się sama zaciągnie z poma głównego
    (jeśli nie działa, to Maven -> root -> Execute Maven goal -> mvn clean install)
    Jeśli zrobimy to dobrze, to po lewej stronie, przy numerze wiersza, pojawi się ikonka,
        której kliknięcie przeniesie nas do odpowiedniej dependency w pomie głównym
8) Dodajemy Spring Container, aby stworzył nam beana,
    i go konfigurujemy - tutaj nie za pomocą adnotacji, ale pliku XML:
    w pakiecie resources tworzymy plik beans.xml
    (podkładka: https://docs.spring.io/spring-framework/docs/current/reference/html/example.html#beans)
    dodajemy tam beana (podając klasę oraz ID)
9) tworzymy instancję Containera:
    w klasie Main (lub innej) dodajemy pole (CONFIG_LOCATION) z lokalizacją beana
    tworzymy kontekst, a następnie wyciągamy z niego beana
    następnie wywołujemy na powyższym odpowiednią metodę
    po wszystkim zamykamy kontener (kontekst)
10) implementujemy logikę gry (interfejs Game i klasa GameImpl)
    dodajemy odpowiedni kod w klasie Main
11) poprawiamy błąd w klasie GameImpl (brak inicjalizacji pola numberGenerator)
    dodajemy w tej klasie konstruktor oraz zmieniamy implementację beana
    -> dodajemy <constructor-arg ref="">, aby wskazać ID, które będzie wstrzyknięte przez kontener
    ref z beana game musi być taki sam jak bean numberGenerator
12) istnieje inny sposób na inicjalizację pola numberGenerator: setter-based dependency injection
    -> kasujemy konstruktor z klasy GameImpl
    -> tworzymy settera dla pola numberGenerator
    -> w bean.xml zmieniamy beana 'game':
        => usuwamy constructor-arg
        => dodajemy property (name musi być takie samo jak nazwa pola w klase GameImpl,
            a ref - takie samo jak nazwa odpowiedniego beana w beans.xml)
13) jeśli stoimy przed wyborem, czy używać setter dependency injection, czy raczej
    constructor dependency injection (DI), Buchalka zaleca constructor DI dla
    dependencies obligatoryjnych, a setter DI dla opcjonalnych
    zespół Springa zaleca stosowanie constructor dependency injection
14) Bean Lifecycle Callbacks
    zazwyczaj do zarządzania cyklem życia beanów używamy metod nazywanych
    init()/initialize() - dla inicjalizacji
    destroy()/dispose() - dla niszczenia/zamykania
    Można też skonfigurować Spring Containera do odszukania odpowiednich metod
        (adnotacje @PostConstruct i @PreDestroy)
    -> z klasy Main usuwamy game.reset()
    -> w beans.xml dodajemy nowego beana:
        <bean class="org.springframework.context.annotation.CommonAnnotationBeanPostProcessor"/>
    -> w głównym pomie dodajemy dependency (Annotation API), a w pomie modułu: to samo, ale bez numeru wersji
    -> w klasie GameImpl nad metodą reset() dodajemy adnotację @PostConstruct
    -> jeśli @PostConstruct świeci się na czerwono: klik -> add Maven Dependency
        -> search for artifact -> wpisać 'javax.annotation' -> add
       alternatywnie: Maven -> mvn clean install